# 技术架构与系统设计学习笔记

> 日期：2026-02-09
> 主题：软件架构设计与系统思维

---

## 一、微服务架构 vs 单体架构

### 1.1 单体架构 (Monolithic Architecture)

**定义**：所有功能模块打包在一个可部署单元中，共享同一个代码库和数据库。

#### 优点
| 优势 | 说明 |
|------|------|
| 开发简单 | 单一项目，无需处理分布式复杂性 |
| 部署便捷 | 一个部署单元，运维成本低 |
| 调试容易 | 整个系统在同一进程，便于问题定位 |
| 性能较好 | 内部调用为进程内通信，无网络开销 |
| 事务处理简单 | 本地事务即可保证数据一致性 |

#### 缺点
| 劣势 | 说明 |
|------|------|
| 扩展性差 | 必须整体扩展，无法针对热点模块独立扩容 |
| 技术债务累积 | 代码库庞大后难以重构，技术栈固化 |
| 部署风险高 | 任何小改动都需要全量部署 |
| 团队规模大后效率下降 | 多人协作冲突多，CI/CD  pipeline 变慢 |
| 故障隔离差 | 一个模块故障可能影响整个系统 |

#### 适用场景
- 初创项目、MVP 阶段
- 团队规模小（< 10人）
- 业务逻辑相对简单
- 需要快速迭代验证市场

---

### 1.2 微服务架构 (Microservices Architecture)

**定义**：将应用拆分为一组小型服务，每个服务独立运行、独立部署，通过轻量级通信机制（通常是 HTTP/REST 或消息队列）交互。

#### 核心特征（AKF 扩展立方体）

```
                    Y轴：功能分解
                         ↑
                         |
    X轴：水平复制 ←──────┼──────→ 水平复制：X轴
    (负载均衡集群)         |
                         ↓
                    Z轴：数据分片
                    (按用户/区域划分)
```

#### 优点
| 优势 | 说明 |
|------|------|
| 独立扩展 | 针对瓶颈服务单独扩容，资源利用率高 |
| 技术异构 | 不同服务可使用最适合的技术栈 |
| 故障隔离 | 单服务故障不会级联导致系统瘫痪 |
| 团队自治 | 小团队负责独立服务，提高开发效率 |
| 独立部署 | 服务可独立发布，降低部署风险 |
| 易于重构 | 服务边界清晰，便于技术演进 |

#### 缺点
| 劣势 | 说明 |
|------|------|
| 分布式复杂性 | 网络延迟、分区容错、一致性问题 |
| 运维成本高 | 需要服务发现、监控、日志聚合等基础设施 |
| 数据一致性挑战 | 分布式事务实现复杂（Saga、TCC 等模式） |
| 测试复杂 | 集成测试需要考虑服务间调用 |
| 开发 overhead | 需要处理服务间通信、容错等基础设施代码 |

#### 适用场景
- 业务复杂、领域边界清晰的大型系统
- 团队规模较大（> 30人），可按领域拆分团队
- 需要独立扩展特定模块
- 需要多技术栈并存

---

### 1.3 决策框架：如何选择？

```
                    业务复杂度
         低 ←────────────────────────→ 高
         ┌───────────────────────────────┐
    高   │     微服务（领域驱动设计）      │
团队规模 │                               │
         │    单体 + 模块化（Modular      │
    低   │         Monolith）            │
         └───────────────────────────────┘
```

**推荐演进路径**：
```
单体应用 → 模块化单体 → 服务化拆分 → 微服务架构
   (MVP)      (成长)      (规模化)      (成熟)
```

---

## 二、事件驱动架构 (Event-Driven Architecture, EDA)

### 2.1 核心概念

**事件驱动架构**是一种以事件为核心进行通信的软件架构模式，系统组件通过异步事件进行松耦合协作。

```
┌─────────────┐     事件发布      ┌─────────────┐
│   事件源     │ ───────────────→ │   事件总线    │
│  (Producer) │                  │   (Broker)  │
└─────────────┘                  └──────┬──────┘
                                        │
                    ┌───────────────────┼───────────────────┐
                    ↓                   ↓                   ↓
              ┌─────────┐         ┌─────────┐         ┌─────────┐
              │ 消费者A  │         │ 消费者B  │         │ 消费者C  │
              │(Consumer)│        │(Consumer)│        │(Consumer)│
              └─────────┘         └─────────┘         └─────────┘
```

### 2.2 核心组件

| 组件 | 职责 | 常见技术 |
|------|------|---------|
| **事件源 (Producer)** | 生成并发布业务事件 | 应用服务、数据库 CDC |
| **事件总线 (Broker)** | 接收、路由、存储事件 | Kafka、RabbitMQ、NATS |
| **事件消费者 (Consumer)** | 订阅并处理感兴趣的事件 | 独立服务、函数计算 |
| **事件存储 (Event Store)** | 持久化事件流，支持事件溯源 | EventStoreDB、Kafka |

### 2.3 事件类型

```
┌─────────────────────────────────────────────────────┐
│                    事件分类                          │
├─────────────────┬─────────────────┬─────────────────┤
│   领域事件       │    集成事件      │   系统事件      │
│ (Domain Event)  │(Integration     │(System Event)   │
│                 │     Event)      │                 │
├─────────────────┼─────────────────┼─────────────────┤
│ • 订单已创建     │ • 跨服务通知     │ • 服务启动      │
│ • 支付已完成     │ • 数据同步       │ • 健康检查      │
│ • 库存已扣减     │ • 状态广播       │ • 告警触发      │
├─────────────────┼─────────────────┼─────────────────┤
│ 语义：业务事实   │ 语义：服务间协作  │ 语义：运维监控   │
│ 范围：领域内     │ 范围：跨服务     │ 范围：基础设施   │
└─────────────────┴─────────────────┴─────────────────┘
```

### 2.4 架构模式

#### 模式一：发布-订阅 (Pub-Sub)
```
发布者 ──→ 主题/Topic ←── 订阅者1
             ↑
             └── 订阅者2
             └── 订阅者3
```
- 一对多通信
- 消费者相互独立
- 适用于广播场景（如：订单创建后通知库存、物流、营销服务）

#### 模式二：事件溯源 (Event Sourcing)
```
命令 → 业务逻辑 → 生成事件 → 事件存储 → 投影到读模型
                       ↓
                    事件流 (不可变)
```
- 以事件流为唯一真相源
- 支持状态回放和审计
- 典型应用：金融交易系统、版本控制

#### 模式三：CQRS (命令查询职责分离)
```
       写模型 (Write Model)
命令 ──→ 命令处理器 ──→ 事件存储 ──→ 事件处理器 ──→ 读模型 (Read Model)
                                                          ↑
查询 ─────────────────────────────────────────────────────┘
```
- 读写分离，独立优化
- 写模型关注一致性，读模型关注性能
- 常与 Event Sourcing 结合使用

### 2.5 优缺点分析

**优点**：
- ✅ 高度解耦：服务间无需知道彼此存在
- ✅ 弹性伸缩：消费者可独立扩容
- ✅ 高可用：异步处理天然具备容错能力
- ✅ 实时响应：流式处理支持近实时数据分析

**缺点**：
- ❌ 最终一致性：数据同步存在延迟
- ❌ 调试困难：异步链路追踪复杂
- ❌ 事件治理：需要事件 schema 管理
- ❌ 顺序保证：全局顺序难以保证

---

## 三、API 设计最佳实践

### 3.1 RESTful API 设计原则

#### URL 设计规范
```
# ✅ 正确示例
GET    /api/v1/users              # 获取用户列表
GET    /api/v1/users/{id}         # 获取特定用户
POST   /api/v1/users              # 创建用户
PUT    /api/v1/users/{id}         # 全量更新用户
PATCH  /api/v1/users/{id}         # 部分更新用户
DELETE /api/v1/users/{id}         # 删除用户

GET    /api/v1/users/{id}/orders  # 获取用户的订单（子资源）

# ❌ 错误示例
GET    /api/v1/getUserById        # 动作不应出现在 URL 中
POST   /api/v1/users/deleteUser   # 应使用 DELETE 方法
GET    /api/v1/users/delete/{id}  # GET 不应该有副作用
```

#### HTTP 状态码规范

| 状态码 | 使用场景 | 示例 |
|--------|---------|------|
| 200 OK | 成功响应 | GET 请求返回数据 |
| 201 Created | 资源创建成功 | POST 创建用户后返回 |
| 204 No Content | 成功但无返回体 | DELETE 成功 |
| 400 Bad Request | 请求参数错误 | 缺少必填字段 |
| 401 Unauthorized | 未认证 | Token 缺失或过期 |
| 403 Forbidden | 无权限 | 权限不足 |
| 404 Not Found | 资源不存在 | 用户 ID 不存在 |
| 409 Conflict | 资源冲突 | 重复创建 |
| 422 Unprocessable | 语义错误 | 业务规则验证失败 |
| 429 Too Many Requests | 限流 | 请求频率过高 |
| 500 Internal Error | 服务器内部错误 | 未捕获异常 |

#### 响应体结构
```json
{
  "success": true,
  "data": {
    "id": "usr_123456",
    "name": "张三",
    "email": "zhangsan@example.com"
  },
  "meta": {
    "requestId": "req_abc123",
    "timestamp": "2026-02-09T10:30:00Z"
  },
  "error": null
}

// 错误响应
{
  "success": false,
  "data": null,
  "meta": {
    "requestId": "req_abc124",
    "timestamp": "2026-02-09T10:31:00Z"
  },
  "error": {
    "code": "USER_NOT_FOUND",
    "message": "用户不存在",
    "details": {
      "userId": "usr_999999"
    }
  }
}
```

### 3.2 API 版本控制策略

```
# 方案1：URL 路径（推荐）
/api/v1/users
/api/v2/users

# 方案2：请求头
Accept: application/vnd.api+json;version=2

# 方案3：查询参数
/api/users?version=2
```

**版本演进策略**：
```
v1 (稳定) ────────────────────────────────
              \
               v2 (开发中) ────────────────
                              \
                               v3 (实验性)
```

### 3.3 分页、过滤与排序

```
# 分页
GET /api/v1/users?page=1&pageSize=20
GET /api/v1/users?cursor=eyJpZCI6MTAwfQ==&limit=20  # 游标分页

# 过滤
GET /api/v1/users?status=active&role=admin
GET /api/v1/orders?createdAt[gte]=2026-01-01&createdAt[lte]=2026-01-31

# 排序
GET /api/v1/users?sort=-createdAt,+name  # -desc, +asc

# 字段选择
GET /api/v1/users?fields=id,name,email
```

### 3.4 API 安全最佳实践

```
┌─────────────────────────────────────────────────────┐
│                  API 安全分层                        │
├─────────────────────────────────────────────────────┤
│  传输层: HTTPS / TLS 1.3                            │
├─────────────────────────────────────────────────────┤
│  认证层: OAuth 2.0 + JWT / API Key                   │
├─────────────────────────────────────────────────────┤
│  授权层: RBAC / ABAC / OAuth Scope                   │
├─────────────────────────────────────────────────────┤
│  防护层: 限流(Rate Limit) / WAF / 输入验证            │
├─────────────────────────────────────────────────────┤
│  审计层: 日志记录 / 异常监控                          │
└─────────────────────────────────────────────────────┘
```

---

## 四、可扩展性与容错设计

### 4.1 可扩展性设计模式

#### 水平扩展 (Scale Out)
```
         负载均衡器
              │
    ┌─────────┼─────────┐
    ↓         ↓         ↓
┌───────┐ ┌───────┐ ┌───────┐
│ 实例1  │ │ 实例2  │ │ 实例3  │  ← 根据负载动态扩缩容
└───────┘ └───────┘ └───────┘
    └─────────┬─────────┘
              ↓
         共享数据库
         (读写分离)
```

#### 读写分离
```
          写请求 ──────→ 主库 (Master)
                          │
                          │ 同步复制
                          ↓
         读请求 ──────→ 从库 (Slave 1..N)
```

#### 分片 (Sharding)
```
按用户ID分片：
用户ID % 4 = 0 → 分片0
用户ID % 4 = 1 → 分片1
用户ID % 4 = 2 → 分片2
用户ID % 4 = 3 → 分片3
```

### 4.2 容错设计模式

#### 1. 熔断器模式 (Circuit Breaker)
```
    关闭 (Closed)              打开 (Open)
    正常处理请求     失败阈值      快速失败
         │         ───────→        │
         │         超时时间         │
         │ ←────────────────────── │
         │      半开 (Half-Open)    │
         │ ←────────────────────── │
              测试请求成功
```

**实现要点**：
- 失败阈值：连续失败 N 次后熔断
- 熔断时长：熔断后等待时间
- 半开状态：允许部分请求测试服务恢复
- 常用库：Hystrix、Resilience4j、Polly

#### 2. 重试模式 (Retry)
```python
# 指数退避策略
retry_count = 0
while retry_count < max_retries:
    try:
        return call_service()
    except TransientError:
        retry_count += 1
        wait_time = min(base_delay * (2 ** retry_count), max_delay)
        sleep(wait_time + random_jitter())
raise MaxRetryExceeded()
```

**注意事项**：
- 只对幂等操作重试
- 使用指数退避避免雪崩
- 设置最大重试次数和超时时间

#### 3. 舱壁模式 (Bulkhead)
```
┌─────────────────────────────────────┐
│           线程池隔离                  │
├─────────────┬─────────────┬─────────┤
│  用户服务    │  订单服务    │  库存服务 │
│  线程池(50)  │  线程池(50)  │ 线程池(50)│
├─────────────┴─────────────┴─────────┤
│          共享连接池 (如需要)           │
└─────────────────────────────────────┘
```
- 资源隔离防止故障扩散
- 为不同服务分配独立线程池/连接池

#### 4. 降级模式 (Fallback)
```
主服务故障 ──→ 降级方案
    │              │
    │              ├── 返回缓存数据
    │              ├── 返回默认值/简化版
    │              └── 切换到备用服务
    ↓
优雅失败，核心功能可用
```

### 4.3 高可用架构示例

```
                    ┌─────────────┐
                    │   CDN       │
                    └──────┬──────┘
                           ↓
┌─────────────┐      ┌─────────────┐      ┌─────────────┐
│  健康检查    │ ←──→ │  负载均衡器  │ ←──→ │  健康检查    │
│  (Health)   │      │   (HAProxy) │      │  (Health)   │
└─────────────┘      └──────┬──────┘      └─────────────┘
                            │
           ┌────────────────┼────────────────┐
           ↓                ↓                ↓
      ┌─────────┐     ┌─────────┐     ┌─────────┐
      │  API    │     │  API    │     │  API    │
      │ Gateway │     │ Gateway │     │ Gateway │
      └────┬────┘     └────┬────┘     └────┬────┘
           │                │                │
           └────────────────┼────────────────┘
                            ↓
              ┌─────────────────────────┐
              │     服务网格/注册中心      │
              │   (Service Mesh/etcd)   │
              └─────────────────────────┘
```

---

## 五、复杂系统接口设计

### 5.1 接口设计原则

#### SOLID 原则在接口设计中的应用

| 原则 | 接口设计应用 |
|------|-------------|
| **S**ingle Responsibility | 一个接口只负责一种类型的交互 |
| **O**pen/Closed | 接口可扩展，不修改已有接口 |
| **L**iskov Substitution | 实现类可互换，不影响调用方 |
| **I**nterface Segregation | 避免胖接口，按使用方拆分 |
| **D**ependency Inversion | 依赖抽象接口，不依赖具体实现 |

### 5.2 分层接口设计

```
┌─────────────────────────────────────────────────────────┐
│                    表现层 (Presentation)                 │
│              REST API / GraphQL / gRPC                   │
│                  DTO (Data Transfer Object)              │
├─────────────────────────────────────────────────────────┤
│                    应用层 (Application)                  │
│              应用服务、用例编排、事务控制                  │
├─────────────────────────────────────────────────────────┤
│                    领域层 (Domain)                       │
│        领域实体、值对象、领域服务、领域事件                 │
├─────────────────────────────────────────────────────────┤
│                    基础设施层 (Infrastructure)            │
│          仓储接口实现、消息队列客户端、外部服务调用          │
└─────────────────────────────────────────────────────────┘
```

### 5.3 接口契约设计

#### OpenAPI/Swagger 规范示例
```yaml
openapi: 3.0.0
info:
  title: 电商订单服务 API
  version: 1.0.0
paths:
  /orders:
    post:
      summary: 创建订单
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateOrderRequest'
      responses:
        201:
          description: 订单创建成功
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Order'
        400:
          $ref: '#/components/responses/BadRequest'
        409:
          $ref: '#/components/responses/Conflict'

components:
  schemas:
    CreateOrderRequest:
      type: object
      required: [userId, items]
      properties:
        userId:
          type: string
          pattern: '^usr_[a-z0-9]{6,}$'
        items:
          type: array
          minItems: 1
          items:
            $ref: '#/components/schemas/OrderItem'
```

### 5.4 防破坏设计 (Anti-Corruption Layer)

```
┌─────────────┐      ┌──────────────────┐      ┌─────────────┐
│   我们的    │      │   防腐层 (ACL)    │      │  外部系统    │
│   领域模型   │ ←──→ │  - 适配器         │ ←──→ │  (遗留/第三方)│
│             │      │  - 转换器         │      │             │
│  干净领域    │      │  - 防腐接口       │      │  混乱接口    │
└─────────────┘      └──────────────────┘      └─────────────┘
```

**作用**：
- 隔离外部系统的变化对核心领域的影响
- 统一外部接口的不一致性
- 保护领域模型的纯净性

---

## 六、实际案例分析

### 案例 1：电商订单系统架构演进

#### 阶段一：单体应用（初创期）
```
┌─────────────────────────────────────┐
│           电商单体应用               │
│  ┌─────────┐ ┌─────────┐ ┌────────┐ │
│  │ 用户模块 │ │ 商品模块 │ │ 订单模块 │ │
│  └─────────┘ └─────────┘ └────────┘ │
│              共享数据库               │
└─────────────────────────────────────┘
```
**问题**：订单高峰期整站卡顿，无法单独扩容订单服务

#### 阶段二：服务拆分（成长期）
```
┌─────────┐   ┌─────────┐   ┌─────────┐
│ 用户服务 │   │ 商品服务 │   │ 订单服务 │
│ (MySQL) │   │ (MySQL) │   │ (MySQL) │
└────┬────┘   └────┬────┘   └────┬────┘
     │              │              │
     └──────────────┼──────────────┘
                    ↓
              ┌─────────────┐
              │   API 网关   │
              └─────────────┘
```
**问题**：服务间同步调用，耦合度高，级联故障

#### 阶段三：事件驱动（成熟期）
```
订单服务 ──→ 订单已创建事件 ──→ Kafka ──→ 库存服务（扣减库存）
                                      ──→ 支付服务（发起支付）
                                      ──→ 物流服務（准备发货）
                                      ──→ 营销服务（发送通知）
```
**效果**：
- 订单服务响应时间从 800ms 降至 50ms
- 库存服务故障不再影响订单创建
- 支持峰值 10 万 TPS 的订单创建

---

### 案例 2：分布式事务处理 - Saga 模式

**场景**：电商下单需要同时操作订单、库存、账户三个服务

```
┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐
│  下单   │──→│ 创建订单 │──→│ 扣减库存 │──→│ 扣减余额 │
│ 请求   │    │  (成功)  │    │  (成功)  │    │ (失败)  │
└─────────┘    └─────────┘    └─────────┘    └────┬────┘
     │                    ↑                       │
     │                    │                       │
     │                    │ 补偿操作              │
     │                    │ ┌─────────┐          │
     │                    └─│ 恢复库存 │←─────────┘
     │                      └─────────┘
     │                      ┌─────────┐
     └────────────────────→│ 取消订单 │
                           └─────────┘
```

**Saga 两种实现方式**：

| 方式 | 说明 | 适用场景 |
|------|------|---------|
| **编排式** (Choreography) | 各服务完成操作后发送事件，由其他服务监听并执行下一步 | 流程简单、服务少 |
| **编排式** (Orchestration) | 由 Saga 协调器统一指挥各服务的操作和补偿 | 流程复杂、需要中央控制 |

---

### 案例 3：高并发缓存架构

**场景**：热点商品详情页，QPS 10万+

```
用户请求 ──→ CDN ──→ 边缘缓存
                │
                └── 未命中 ──→ 负载均衡 ──→ 应用集群
                                          │
                              ┌───────────┼───────────┐
                              ↓           ↓           ↓
                          本地缓存    Redis集群    数据库
                          (Caffeine)  (分片)     (主从)
                          
缓存策略：
- L1: CDN 缓存 (静态资源)
- L2: 本地缓存 (热点数据，TTL 10s)
- L3: Redis 分布式缓存 (TTL 1h)
- L4: 数据库
```

**关键技术点**：
- **缓存穿透**：布隆过滤器拦截无效 key
- **缓存击穿**：热点 key 互斥锁重建
- **缓存雪崩**：随机 TTL + 多级缓存
- **数据一致性**：Cache-Aside 模式 + 消息队列最终一致

---

## 七、架构设计原则总结

### 7.1 核心原则

```
┌────────────────────────────────────────────────────────────┐
│                     架构设计核心原则                         │
├────────────────────────────────────────────────────────────┤
│                                                            │
│   1. KISS (Keep It Simple, Stupid)                         │
│      → 如无必要，勿增复杂度                                  │
│                                                            │
│   2. YAGNI (You Ain't Gonna Need It)                       │
│      → 不要为未来可能的需求过度设计                          │
│                                                            │
│   3. 关注点分离 (Separation of Concerns)                    │
│      → 每个模块只负责一件事                                  │
│                                                            │
│   4. 单一职责 (Single Responsibility)                       │
│      → 一个类/服务只有一个变化理由                           │
│                                                            │
│   5. 开闭原则 (Open/Closed)                                 │
│      → 对扩展开放，对修改关闭                                │
│                                                            │
│   6. 依赖倒置 (Dependency Inversion)                        │
│      → 依赖抽象，不依赖具体实现                              │
│                                                            │
│   7. 防御性编程 (Defensive Programming)                     │
│      →  fail fast，优雅降级，熔断限流                        │
│                                                            │
│   8. 可观测性 (Observability)                               │
│      → 日志、指标、追踪三位一体                               │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

### 7.2 决策检查清单

在做出架构决策前，问自己：

- [ ] 这个设计是否满足当前业务需求？
- [ ] 未来6-12个月业务增长时，能否平滑扩展？
- [ ] 单点故障在哪里？如何消除？
- [ ] 性能瓶颈可能在哪里？如何监控？
- [ ] 团队能否理解和维护这个设计？
- [ ] 技术债务是否在可控范围？

### 7.3 学习资源推荐

| 类型 | 资源 |
|------|------|
| 书籍 | 《构建高性能Web站点》《微服务设计》《数据密集型应用系统设计》 |
| 模式 | Martin Fowler 的微服务架构模式 |
| 实践 | Netflix Tech Blog、阿里巴巴技术博客 |
| 工具 | Kubernetes、Istio、Prometheus、Jaeger |

---

## 八、总结

架构设计没有银弹，关键在于：

1. **从业务出发**：技术服务于业务，架构应支持业务目标
2. **渐进式演进**：从简单开始，随业务成长逐步演化
3. **可逆性优先**：保持架构的灵活性，便于调整
4. **关注非功能性需求**：性能、可用性、可维护性同等重要
5. **持续学习**：架构领域不断发展，保持对新模式的敏感度

> "好架构是演化出来的，不是设计出来的。" —— 但演化需要良好的设计基础。

---

*学习完成时间：2026-02-09*
