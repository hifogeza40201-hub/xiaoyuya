# 阶段4：工具使用与任务执行 - 最佳实践研究

> 研究时间: 2026-02-09  
> 主题: 如何高效使用工具和完成复杂任务

---

## 一、工具链整合：工具间的配合与数据流转

### 1.1 工具分类与功能映射

| 工具类型 | 核心功能 | 适用场景 |
|---------|---------|---------|
| **read/write/edit** | 文件操作 | 配置管理、代码修改、文档编写 |
| **exec/process** | 命令执行 | 系统管理、自动化脚本、后台任务 |
| **web_search/web_fetch** | 信息获取 | 研究、验证、实时数据查询 |
| **browser** | 浏览器控制 | UI自动化、网页测试、数据提取 |
| **canvas** | 可视化展示 | 图表生成、UI预览、图像处理 |
| **message** | 通信发送 | 通知、告警、外部集成 |
| **nodes** | 节点管理 | 远程设备控制、多机协作 |
| **tts** | 语音合成 | 语音输出、可访问性支持 |

### 1.2 数据流转模式

```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  数据获取    │───▶│  数据处理    │───▶│  结果输出    │
│  (search)   │    │  (exec/edit)│    │  (write/msg)│
└─────────────┘    └─────────────┘    └─────────────┘
        │                  │                  │
        ▼                  ▼                  ▼
   web_fetch获取      文件读写转换       多渠道分发
   原始数据           数据清洗加工       (文件/消息)
```

### 1.3 工具链最佳实践

**✅ DO - 推荐做法**

1. **单一职责原则**
   - 每个工具调用只做一件事
   - 避免在单个exec中串联多个不相关命令
   - 复杂任务拆分为多个原子操作

2. **数据管道化**
   ```python
   # 好：清晰的流水线
   web_search → web_fetch → read → edit → write
   
   # 避免：跳跃式调用
   search结果直接edit，中间缺少验证
   ```

3. **格式一致性**
   - JSON数据使用`write`配合JSON.stringify
   - Markdown使用标准格式，便于后续`read`
   - 配置文件优先使用结构化格式(YAML/JSON)

4. **上下文传递**
   ```markdown
   - 搜索结果 → 保存到临时文件 → 后续步骤读取
   - 避免：依赖记忆，多次重复搜索
   ```

**❌ AVOID - 避免事项**

- 在单次调用中混用不兼容的工具
- 忽略工具返回结果，直接进行下一步
- 工具间数据格式不统一导致解析失败

---

## 二、任务分解：复杂任务的拆解与规划

### 2.1 任务分解方法论

#### 2.1.1 MECE原则 (Mutually Exclusive, Collectively Exhaustive)

```
复杂任务
├── 子任务A (独立执行)
├── 子任务B (依赖A的结果)
├── 子任务C (可并行执行)
└── 子任务D (最终结果汇总)
```

#### 2.1.2 任务依赖分析

| 依赖类型 | 特征 | 处理策略 |
|---------|------|---------|
| **强依赖** | 必须等待前置任务完成 | 串行执行，检查前置状态 |
| **弱依赖** | 有前置更好，但没有也能继续 | 设置默认值，继续执行 |
| **无依赖** | 完全独立 | 并行执行，提高效率 |

### 2.2 任务规划模板

```markdown
## 任务执行计划

### 目标
[清晰描述最终目标]

### 步骤分解
1. **[步骤1名称]** - 预计耗时
   - 输入: [需要的数据/资源]
   - 工具: [使用的工具]
   - 输出: [产生的结果]
   - 验证: [如何确认成功]

2. **[步骤2名称]** - 预计耗时
   - 依赖: [依赖的步骤]
   - ...

### 风险点
- [可能失败的地方]
- [备选方案]

### 回退策略
- 如果步骤X失败 → 执行Y
```

### 2.3 实际案例：多源信息整合任务

```
任务: 研究某技术并输出报告

分解:
├─ 阶段1: 信息收集 (可并行)
│  ├─ 1.1 搜索引擎查询 (web_search)
│  ├─ 1.2 抓取权威文档 (web_fetch)
│  └─ 1.3 查看本地知识库 (read)
│
├─ 阶段2: 信息整合 (依赖阶段1)
│  ├─ 2.1 去重和分类
│  ├─ 2.2 提取关键信息
│  └─ 2.3 生成大纲
│
└─ 阶段3: 报告输出 (依赖阶段2)
   ├─ 3.1 撰写正文 (write)
   └─ 3.2 格式化检查
```

---

## 三、错误处理：识别失败、优雅降级、备选方案

### 3.1 错误分类与处理策略

| 错误类型 | 识别方式 | 处理策略 |
|---------|---------|---------|
| **工具调用失败** | 返回非零exit code | 重试→备选工具→人工介入 |
| **网络超时** | 请求无响应 | 指数退避重试→缓存数据→降级 |
| **数据解析失败** | 格式不匹配 | 尝试其他解析器→记录原始数据 |
| **权限不足** | Access Denied | 请求授权→使用替代路径 |
| **资源不存在** | 404/Not Found | 创建→使用默认值→跳过 |

### 3.2 错误处理模式

#### 模式1: 重试机制

```
执行操作
   │
   ▼ 失败?
重试计数 < 3? ──是──▶ 等待(指数退避) ──▶ 重试
   │
   否
   ▼
执行备选方案 / 报告错误
```

#### 模式2: 降级策略

```
主方案: 使用高级API获取详细数据
   │ 失败
   ▼
降级1: 使用基础API获取核心数据
   │ 失败
   ▼
降级2: 使用本地缓存数据
   │ 失败
   ▼
最终降级: 返回提示信息，告知用户当前无法获取
```

#### 模式3: 断路器模式 (Circuit Breaker)

```
正常状态 ──▶ 连续失败N次 ──▶ 断开状态
                              │
                              ▼ 等待恢复时间
                              半开状态 ──▶ 测试请求成功 ──▶ 正常状态
```

### 3.3 优雅降级示例

```markdown
## 文件操作的安全降级

### 场景: 写入配置文件

**主路径:**
1. 尝试写入目标路径
2. 失败? 检查原因

**降级路径:**
- 权限不足 → 尝试用户目录 → 尝试临时目录
- 磁盘满 → 清理日志 → 压缩旧文件 → 重试
- 路径不存在 → 创建父目录 → 重试

**最终保证:**
- 至少记录到内存或返回给用户
```

---

## 四、并行执行：多任务协调、资源分配

### 4.1 何时并行

**适合并行:**
- ✅ 独立的网络请求 (web_search + 多个web_fetch)
- ✅ 独立的文件读取
- ✅ 不相关的数据处理任务

**必须串行:**
- ❌ 前后有数据依赖的任务
- ❌ 涉及同一资源的写操作
- ❌ 需要严格顺序保证的操作

### 4.2 并行执行策略

#### 4.2.1 批量并行 (Map-Reduce模式)

```
Map阶段 (并行执行):
├─ 任务A → 结果A
├─ 任务B → 结果B
└─ 任务C → 结果C

Reduce阶段 (聚合):
└─ 合并结果A+B+C → 最终输出
```

#### 4.2.2 流水线并行 (Pipeline)

```
阶段1        阶段2        阶段3
[获取数据] → [处理数据] → [输出结果]
   ↓            ↓            ↓
数据1        处理1        输出1
数据2        处理2        输出2
数据3        处理3        输出3
```

### 4.3 资源分配原则

| 资源类型 | 限制因素 | 建议策略 |
|---------|---------|---------|
| **API配额** | 调用次数/分钟 | 批处理 + 速率限制 |
| **内存** | 单次响应大小 | 流式处理 + 分页 |
| **磁盘** | 空间/IO | 临时文件清理 + 压缩 |
| **网络** | 带宽/连接数 | 连接复用 + 压缩传输 |

### 4.4 并行执行示例

```markdown
## 场景: 分析多个网页

### 串行方案 (低效)
1. fetch URL1 → 分析 → fetch URL2 → 分析 → ...

### 并行方案 (高效)
1. 同时fetch所有URL (并行)
2. 收集所有结果
3. 批量分析处理
4. 统一输出报告
```

---

## 五、结果验证：输出检查、质量保证、反馈迭代

### 5.1 验证层级

```
Level 1: 语法验证
   │ 检查输出格式是否正确
   ▼
Level 2: 内容验证
   │ 检查内容是否符合预期
   ▼
Level 3: 逻辑验证
   │ 检查逻辑是否自洽
   ▼
Level 4: 用户验证
   └ 用户确认满意度
```

### 5.2 质量保证检查清单

#### 5.2.1 文件输出检查

- [ ] 文件成功创建/修改
- [ ] 内容格式正确 (JSON/Markdown/等)
- [ ] 编码正确 (UTF-8无BOM)
- [ ] 大小合理 (无异常膨胀)
- [ ] 可读性良好 (适当换行、缩进)

#### 5.2.2 数据准确性检查

- [ ] 数据来源可靠
- [ ] 数值计算正确
- [ ] 无明显的逻辑错误
- [ ] 信息时效性 (日期、版本)

#### 5.2.3 任务完整性检查

- [ ] 所有步骤执行完成
- [ ] 目标达成
- [ ] 无明显遗漏
- [ ] 文档已更新

### 5.3 反馈迭代机制

```
         ┌─────────────┐
         │   执行任务   │
         └──────┬──────┘
                │
                ▼
         ┌─────────────┐
         │   验证结果   │
         └──────┬──────┘
                │
        ┌───────┴───────┐
        │               │
       通过            失败
        │               │
        ▼               ▼
   ┌─────────┐    ┌─────────────┐
   │  完成   │    │  分析原因   │
   └─────────┘    └──────┬──────┘
                         │
                         ▼
                  ┌─────────────┐
                  │  修正执行   │
                  └──────┬──────┘
                         │
                         └──────▶ [重新验证]
```

### 5.4 迭代改进模板

```markdown
## 执行复盘

### 本次执行
- 目标: [原始目标]
- 耗时: [实际耗时]
- 结果: [成功/部分成功/失败]

### 问题记录
1. **问题**: [描述]
   - 原因: [根本原因]
   - 解决: [如何解决的]
   - 预防: [下次如何避免]

### 经验沉淀
- ✅ 有效的方法: [记录下来]
- ⚠️ 需要注意: [警示事项]
- 📚 新知识: [学习到的东西]

### 流程优化建议
- [可以改进的地方]
```

---

## 六、综合最佳实践总结

### 6.1 执行前准备

1. **理解目标** - 确认需求，明确成功标准
2. **评估复杂度** - 决定是否需要任务分解
3. **检查资源** - 确认工具可用，权限充足
4. **规划回退** - 准备Plan B

### 6.2 执行中原则

1. **小步快跑** - 频繁验证，及时发现问题
2. **保持记录** - 关键步骤记录到memory
3. **优雅降级** - 主路径失败时启用备选
4. **资源监控** - 关注API配额、磁盘空间等

### 6.3 执行后收尾

1. **结果验证** - 按检查清单确认质量
2. **文档更新** - 将经验写入AGENTS.md/MEMORY.md
3. **资源清理** - 删除临时文件，释放资源
4. **复盘总结** - 记录可复用的模式

### 6.4 效率提升技巧

| 技巧 | 说明 | 效果 |
|-----|------|-----|
| **模板复用** | 建立任务执行模板 | 减少规划时间 |
| **工具链预设** | 常用工具组合预配置 | 提高调用效率 |
| **增量更新** | 只修改变化部分 | 减少IO开销 |
| **智能缓存** | 缓存搜索结果、API响应 | 减少重复请求 |
| **批量处理** | 合并同类操作 | 减少API调用次数 |
| **异步执行** | 非阻塞的独立任务 | 缩短总耗时 |

---

## 七、OpenClaw特定建议

基于当前环境(OpenClaw)的特殊考量:

### 7.1 工具调用优化

```markdown
1. **read工具**: 
   - 使用offset/limit处理大文件
   - 优先读取本地缓存而非远程

2. **exec工具**:
   - 使用pty模式处理交互式命令
   - 后台任务使用background参数
   - 超时设置避免无限等待

3. **browser工具**:
   - 使用snapshot获取稳定引用
   - 批量操作使用act的fields参数
   - 优先使用aria-refs保证稳定性

4. **message工具**:
   - 批量通知使用broadcast
   - 区分silent和普通发送
```

### 7.2 安全优先原则

```markdown
1. 外部操作(send/post等)必须确认
2. 删除操作使用trash而非rm
3. 敏感信息不写入共享上下文
4. 不确定时先询问再执行
```

---

## 参考文档

- AGENTS.md - 代理行为准则
- TOOLS.md - 本地工具配置
- 历史memory文件 - 经验教训

---

*本文档将持续更新，每次执行任务后应回顾并补充新的经验。*
